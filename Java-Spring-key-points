In Thread Start method will create a new thread and will execute whatever we have inside run method.
But If we will call only Run method Than It will not create a new thread instead will call existing thread.

#####Internal Working of ConCurrent HashMap
Completable feature In java to manage the concurrent Thread. 

#########Compare List and set for searching
1. Sets are faster than list for searching. Because in List In worst Case we need to iterate till the last element but in set The location of the added element will be 
the corresponding HAsh Value of the added element so During search the value will be fetched directly as per the hashkey of the element to be fetched and will get the result in 
1 Time Complexity even in worst case.


######Map and SingletonMap ############
a. Collections.Singleton map is much better by Memory and Developer perspective when we are in need to have only single key value pair in the map and in future we wouldn't
need to modify or any other element in the map as put in this singleton Map Will throw UnSupoortedOperationException.
b. But in the Simple Map we are free to use and add any element.
c. SingletonMap has to contain two member fields: the key and the value, whereas a HashMap maintains an internal array of Node objects plus other member fields.So 
To use these maps are really prudent choice to use these maps.

###### JPQL Query Spring ###########
1. By Extending Repository<Entity, IndexId> in SPring Repository will help us by following way.
a. It provide us the crud Methods to use for our Repository.
b. It allows us to scan our Repository during classpath scanning.

2. By Extending JPQL Query, Jpa Provides us the Much Flexible to have the Custom Query Like SQL to fetch the data for us from the database.
3. So Any JPA Implementation Framework First will convert JPQL Query to SQL then will execute that on database.
4. By Using @Query Annotation of JPA We can write our custom Query.

############ Transaction in Spring #########################
1. If inside the readOnly Transactions, we call any readOnly=false Transaction then it will flush and Save the Records in to database untill we will create the New 
Transaction for readOnly=false.
2. It Doesn't work since the previous transactional is being continued.
3. @Transactional Annotation we used to have the transaction behaviour in our spring Annotation class or method.

